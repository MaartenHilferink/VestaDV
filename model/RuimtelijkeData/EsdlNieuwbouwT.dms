//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
//                   (C) VESTA 2019 - Planbureau voor de Leefomgeving                   //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////
 
//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
//       Deze DMS-file wordt aangeroepen door ScenarioSpecs.dms.                        //
//       In deze configuratiefile wordt de Nieuwbouw geconfigureerd.                    //
//       Nieuwbouw is gedefinieerd als nieuwe bebouwing in nieuwe gebieden).            //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////
  
template EsdlNieuwbouw
{  
	parameter<string> EsdlPath := Invoer/NieuwbouwWoningEsdlPath;
	
	container VestaBebouwingsComponentSchema
	{
		unit<uint32> measure {
			attribute<string> id;
			attribute<string> name;
		}
		// unit<uint32> kpis
		// {
			// unit<uint32> kpi
			// {
				// attribute<string> id;
				// attribute<string> name;
				// attribute<string> value;
			// }
		// }
		unit<uint32> area
		{
			attribute<string> id;
			attribute<string> name;
			attribute<string> scope;
			unit<uint32> geometry
			{
				attribute<string> CRS;
				attribute<string> lat;
				attribute<string> lon;
			}

			unit<uint32> asset // Building
			{
				attribute<string> xsi_type;
				attribute<string> id;
				attribute<string> name;
				attribute<string> aggregationCount;
				attribute<string> residentialBuildingType; // TODO ESDL: RENAME to BuildingType; specify enumeration according to WoningTypeBestaand, WoningtypeNieuwbouw, UtilType, UtiltypeNieuwbouw, or GLTB
				attribute<string> numberOfFloors;
				attribute<string> buildingYear;
				
				unit<uint32> geometry
				{
					attribute<string> CRS;
					attribute<string> lat;
					attribute<string> lon;
//					attribute<dpoint> ll := point(float64(lat), float64(lon)); // DEBUG issue 1396
				}
				
				unit<uint32> asset // VBO
				{
					attribute<string> xsi_type;
					attribute<string> id;
					attribute<string> type;
					attribute<string> aggregationCount;
					attribute<string> floorArea;
					
					attribute<string> energyLabel;
					
					unit<uint32> geometry
					{
						attribute<string> CRS;
						attribute<string> lat;
						attribute<string> lon;
					}
					
				}
			}
			// unit<uint32> measure {
				// attribute<string> reference;
			// }
		}
	}
	
	parameter<string> ESDL_Nieuwbouw: StorageName = "=EsdlPath", StorageType = "str";
		
	container Parsed_Nieuwbouw:= parse_xml(ESDL_Nieuwbouw, VestaBebouwingsComponentSchema);
	
	unit<uint32> KiesbareMeasure := Parsed_Nieuwbouw/measure
	{
		attribute<Classifications/WarmteOptie> WarmteOptie_rel := rlookup(uppercase(id), uppercase(Classifications/WarmteOptie/name));
	}
	// parameter<bool> StrategieFlip := IsDefined(rlookup(uppercase(SharedInvoer/FullVariantName), uppercase(KiesbareMeasure/id)));
	// parameter<bool> StrategieFlip := TRUE; // HACK gooi en vechtstreek
	
	unit<uint32> EsdlBuurt := Parsed_Nieuwbouw/area
	{
		unit<uint32> Measure := Parsed_Nieuwbouw/area/Measure
		{
			attribute<EsdlBuurt> Buurt_rel := value(Parent_rel, EsdlBuurt);
			attribute<KiesbareMeasure> KiesbareMeasure_rel := rlookup(reference, KiesbareMeasure/id);
			attribute<EsdlBuurt_Measure> EsdlBuurt_Measure_rel := combine_data(EsdlBuurt_Measure, Buurt_rel, KiesbareMeasure_rel);
		}
		attribute<bool> HasMeasure := any(const(true, Measure), Measure/Buurt_rel);
		attribute<string> buurt_name := id;
		attribute<RegioIndelingen/buurt> PlanRegio_rel := rlookup(lowercase(buurt_name), lowercase(RegioIndelingen/buurt/BU_CODE));
		
		attribute<bool> StrategieToegestaan := =ShareInvoer/FlipStatus 
			? 'HasMeasure ? any(uppercase(measure/reference)==uppercase(SharedInvoer/FullVariantName), Measure/Buurt_rel) : true' 
			: 'const(true, .)';
	}
	unit<uint32> EsdlBuurt_Measure := combine(EsdlBuurt, KiesbareMeasure)
	{
		attribute<EsdlBuurt> Buurt_rel := nr_1;
		attribute<KiesbareMeasure> Measure_rel := nr_2;
		
		attribute<bool> Toegestaan := any(const(true, EsdlBuurt/Measure), EsdlBuurt/Measure/EsdlBuurt_Measure_rel) || not(EsdlBuurt/HasMeasure[Buurt_rel]);
	}
	
	parameter<string> CE_Delft_buurtoptie := rjoin(/variantcode, Classifications/VestaVarianten/variantcode, Classifications/VestaVarianten/CE_Delft_buurtoptie);
	
	unit<uint32> Read_FlipCSV 
	:  StorageName     = "='%ProjDir%/ESDL/'+SharedInvoer/StudieGebied+'_voorkeursopties.csv'"
	,  StorageType     = "gdal.vect"
	,  StorageReadOnly = "True"
	{
		attribute<RegioIndelingen/buurt> PlanRegio_rel                    := rlookup(lowercase(bu_code), lowercase(RegioIndelingen/buurt/BU_CODE));
		attribute<string>                Uitkomst_SA;
		attribute<string>                Uitkomst_gecheckt;
		
		attribute<bool>                  StrategieToegestaan_SA           :=  (Uitkomst_SA == CE_Delft_buurtoptie);
		attribute<bool>                  StrategieToegestaan_Check        :=  (Uitkomst_gecheckt == CE_Delft_buurtoptie);
		attribute<bool>                  StrategieToegestaan_GeenGroengas :=  (StrategieToegestaan_SA || Uitkomst_SA == 'Groengas') && !(/variantcode == 's4a' || /variantcode == 's4b'  || /variantcode == 's4c'  || /variantcode == 's4d');
		
		attribute<bool>                  StrategieToegestaan              :=  SharedInvoer/Scenario == '1_SA'
																				? StrategieToegestaan_SA
																				: SharedInvoer/Scenario ==  '2_Check' 
																					? StrategieToegestaan_Check
																					: SharedInvoer/Scenario == '3_GeenGroenGas'
																						? StrategieToegestaan_GeenGroengas
																						: const(true,.);
		
		attribute<bool> StrategieToegestaan_per_buurt(RegioIndelingen/buurt) :=  StrategieToegestaan[invert(PlanRegio_rel)] || not(IsDefined(invert(PlanRegio_rel)));
	}
	
	
	unit<uint32> asset := Parsed_Nieuwbouw/area/asset, FreeData = "false", DialogData = "point_rd", DialogType = "map"  // TODO ESDL: subset(xsi::type == 'Building') NEE: BuildingUnit 
	{
		unit<uint32> Geometry := Parsed_Nieuwbouw/area/asset/Geometry
		{
			attribute<..> asset_rel := value(Geometry/Parent_rel, ..);
		}
		attribute<rdc_meter>  point_rd := LatLongWgs842RD(
			point(
				value(first(Geometry/lat, Geometry/asset_rel), float64)
			,	value(first(Geometry/lon, Geometry/asset_rel), float64)
			,	dpoint)
		, rdc_meter);
		
		attribute<EsdlBuurt> EsdlBuurt_rel := value(Parent_rel, EsdlBuurt);
	}
	
	unit<uint32> Gebouw := subset(asset/xsi_type == "esdl:Building"), FreeData = "false", DialogData = "point_rd", DialogType = "map"  // TODO ESDL: subset(xsi::type == 'Building') NEE: BuildingUnit 
	{
		unit<uint32> Geometry := Subset(IsDefined(invert(nr_OrgEntity)[asset/Geometry/Parent_rel]))
		{
			attribute<.> Gebouw_rel (Geometry) := invert(Gebouw/nr_OrgEntity)[asset/Geometry/asset_rel[nr_OrgEntity]];
		}
		attribute<string> Name := asset/Name[nr_OrgEntity];
		attribute<rdc_meter>  point_rd := asset/point_rd[nr_OrgEntity];
		
		attribute<Classifications/WoningtypeNieuwbouw> Woningtype_rel := 
			rlookup(
				replace_value(
					UpperCase(asset/residentialBuildingType[nr_OrgEntity])
				,	'APPARTEMENTENCOMPLEX', 'APPARTEMENT'
				,	'', 'APPARTEMENT'
				)
			,	UpperCase(Classifications/WoningtypeNieuwbouw/name)
			);
		attribute<Float64> AggregationCount := MakeDefined(Float64(asset/AggregationCount)[nr_OrgEntity], 1.0);
		
		attribute<uint8>   Bouwlagen  := MakeDefined(value(asset/numberOfFloors[nr_OrgEntity], uint8), 4b); // use 4 as default when missing. 
		attribute<uint32>  Bouwjaar   := value(asset/buildingYear[nr_OrgEntity], uint32);
		
		attribute<Classifications/WoningtypeNieuwbouw> Woningtype :=
			WoningType_rel == Classifications/WoningtypeNieuwbouw/V/Appartement 
			&& IsDefined(Bouwlagen) && Bouwlagen > 0b 
		?	Bouwlagen > 4b ? Classifications/WoningtypeNieuwbouw/V/Flat5 : Classifications/WoningtypeNieuwbouw/V/FlatTot4
		:	WoningType_rel;
		
		attribute<EsdlBuurt> EsdlBuurt_rel := asset/EsdlBuurt_rel[nr_OrgEntity];
	}
	
	unit<uint32> BouwObject:= Parsed_Nieuwbouw/area/asset/asset, FreeData = "false", DialogData = "point_rd", DialogType = "map"  // TODO ESDL: subset(xsi::type == 'Building') NEE: BuildingUnit 
	{
		attribute<Gebouw> Gebouw_rel := value(Parent_rel, Gebouw);
		attribute<EsdlBuurt> EsdlBuurt_rel := Gebouw/EsdlBuurt_rel[Gebouw_rel];
		
		unit<uint32> Geometry := Parsed_Nieuwbouw/area/asset/asset/Geometry;
		attribute<.> Geometry_Parent_rel (Geometry) := value(Geometry/Parent_rel, .);
		
		
		attribute<Classifications/BebouwingsComponentBase> BebouwingsComponentBase_rel := 
				type == 'RESIDENTIAL'
				?	Classifications/BebouwingsComponentBase/V/NieuwbouwWoning
				:	Classifications/BebouwingsComponentBase/V/NieuwbouwUtil;
	
		attribute<rdc_meter>  point_rd_direct := LatLongWgs842RD(
			point(
				value(first(Geometry/lat, Geometry_Parent_rel), float64)
			,	value(first(Geometry/lon, Geometry_Parent_rel), float64)
			,	dpoint)
		, rdc_meter);
		
		attribute<rdc_meter>  point_rd := MakeDefined(point_rd_direct, Gebouw/point_rd[Gebouw_rel]);
		
		attribute<m2   >      Oppervlakte:= value(floorArea, m2) * Gebouw/aggregationCount[Gebouw_rel];
		attribute<nrAsl>      nr_aansl   := value(aggregationCount, nrAsl) * Gebouw/aggregationCount[Gebouw_rel];
		attribute<string>     Schillabel := energyLabel;
		
		// WoningType == APPARTEMENT en IsDefined(Bouwlagen) -> FlatTot4 of Flat5ofmeer
		attribute<Classifications/WoningtypeNieuwbouw> Woningtype_rel := Gebouw/WoningType_rel[gebouw_rel];
		attribute<Classifications/UtiltypeNieuwbouw> UtilType_rel := rlookup(uppercase(Parsed_Nieuwbouw/area/asset/asset/type), uppercase(Classifications/UtiltypeNieuwbouw/ESDL_code));
		
		// Oppervlakte
		attribute<pand_asl>   pand_aandeel := value(1.0, nrPand) / value(Gebouw/Bouwlagen[gebouw_rel], nrAsl);
		// Gebouwoptie danwel pakket Installaties voor RuimteVerwarming( basis, piek), Koude(basis, piek), Tapwater(basis, piek)		
		
		// unit<uint32> BouwObject_Measure := combine(BouwObject, KiesbareMeasure)
		// {
			// attribute<BouwObject> BouwObject_rel := nr_1;
			// attribute<EsdlBuurt> EsdlBuurt_rel := BouwObject/EsdlBuurt_rel[nr_1];
			// attribute<KiesbareMeasure> Measure_rel := nr_2;
			
			// attribute<bool> Toegestaan := EsdlBuurt_Measure/Toegestaan[combine_data(EsdlBuurt_Measure, EsdlBuurt_rel, Measure_rel)];
		// }
	}
	template SelectT
	{
		parameter<uint32> zichtjaar;
		parameter<uint32> prev_zichtjaar;
		
		parameter<Classifications/BebouwingsComponentBase> BebouwingsComponentBase_par;
		
		
		unit<uint32> results := subset(
			Gebouw/Bouwjaar[BouwObject/Gebouw_rel] > prev_zichtjaar 
		&&  Gebouw/Bouwjaar[BouwObject/Gebouw_rel] <= zichtjaar    
		&&	BouwObject/BebouwingsComponentBase_rel == BebouwingsComponentBase_par
		)
			, DialogType = "Map"
			, DialogData = "Point"
		{
			attribute<string> Code     := Label;
			attribute<string> TypeName := BouwObject/type[nr_OrgEntity];
			attribute<string> Label    := Classifications/BebouwingsComponentBase/name[BebouwingsComponentBase_par] + string(zichtjaar) + string(BouwObject/id[nr_OrgEntity]), DialogType = "LabelText";

			unit<uint8> BebouwingsTypeDomein := ='Classifications/'+Classifications/BebouwingsComponentBase/TypeName[BebouwingsComponentBase_par];
			unit<uint8> ModelObjectKeyDomein := combine_uint8(BebouwingsTypeDomein, Classifications/BouwJaar);

			attribute<nrAsl>                              nrAansluitingen_i  := MakeDefined(BouwObject/nr_aansl   [nr_OrgEntity], 1[nrAsl]);
			attribute<m2>                                 Oppervlakte_i      := BouwObject/oppervlakte[nr_OrgEntity];
			
			//initial state
			attribute<Classifications/Schillabel>         SchilLabel_rel     := MakeDefined(rlookup(BouwObject/schillabel [nr_OrgEntity], Classifications/Schillabel/name), Classifications/Schillabel/V/A);
			attribute<Classifications/WarmteOptie>        WarmteOptie_rel    := const(Classifications/WarmteOptie/V/geen, .);
			container InstallatiePerProduct := for_each_nedv(Classifications/Product/name
				, 'const(Classifications/Installatie/V/geen, ..)'
				, ., Classifications/Installatie
			)
			{
				attribute<Classifications/Installatie> Dak (..) := const(Classifications/Installatie/V/geen, ..); //TODO_OV
			}
			attribute<Classifications/AfgifteSysteem> AfgifteSysteem_rel := const(Classifications/AfgifteSysteem/V/geen, .);
			attribute<uint32>                         AfnameGebied_rel   := const(0/0, .);		
			
			attribute<Geography/rdc_meter>                Point              := BouwObject/point_rd   [nr_OrgEntity];
			attribute<Invoer/RuimtelijkeData/StudieGebied/buurt> buurt_rel   := point_in_polygon(point, Invoer/RuimtelijkeData/StudieGebied/buurt/geometry );
			
			attribute<BebouwingsTypeDomein>               BebouwingsType     := 
				=(BebouwingsComponentBase_par == Classifications/BebouwingsComponentBase/V/BestaandeWoning ||
				BebouwingsComponentBase_par == Classifications/BebouwingsComponentBase/V/NieuwbouwWoning)		
				?	'BouwObject/WoningType_rel[nr_OrgEntity]'
				:	'BouwObject/UtilType_rel[nr_OrgEntity]';
				
			attribute<int32>                              BouwJaar_int32     := min_elem(int32(Gebouw/Bouwjaar[BouwObject/Gebouw_rel[nr_OrgEntity]]), max(int32(Classifications/BouwJaar/ClassBreak)));
			attribute<Classifications/BouwJaar>           Bouwjaar           := classify(10000i-BouwJaar_int32, 10000i-int32(Classifications/BouwJaar/ClassBreak));
			attribute<ModelObjectKeyDomein>               ModelObjectKey     := combine_data(ModelObjectKeyDomein, BebouwingsType, BouwJaar);

			attribute<pand_asl>                           pand_aandeel       := BouwObject/pand_aandeel[nr_OrgEntity];

			container Gebied
			{
				attribute<float64> n      (..) := value(nrAansluitingen_i,float64);
				attribute<float64> MEAN_x (..) := PointRow(Point);
				attribute<float64> MEAN_y (..) := PointCol(Point);
				attribute<float64> SSD_xx (..) := sqrt(n*10d);
				attribute<float64> SSD_xy (..) := sqrt(n*10d);
				attribute<float64> SSD_yy (..) := sqrt(n*10d);
			}

			container Kapitaallasten
			{
				//Aansluitbijdrages
				attribute<Eur_yr> Kji_Asl_Enet (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kmi_Asl_Enet (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kji_Asl_Gnet (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kmi_Asl_Gnet (..) := const(0[EUR_yr], ..);

				//Investeringen
				attribute<Eur_yr> Kji30_LO (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kmi30_LO (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kji20_LO (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kmi20_LO (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kji15_LO (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kmi15_LO (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kji_gv   (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kmi_gv   (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Kj_gv_incentive(..) := const(0[Eur_yr], ..);

				attribute<Eur_yr> Kji_LTAS (..) := const(0[Eur_yr], ..);
				attribute<Eur_yr> Kmi_LTAS (..) := const(0[Eur_yr], ..);

				//Subsidies
				attribute<Eur_yr> Oji_s_LO_30 (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Oji_s_LO_20 (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Oji_s_LO_15 (..) := const(0[EUR_yr], ..);
				attribute<Eur_yr> Oji_s_gv    (..) := const(0[EUR_yr], ..);
			}
			container Criteria;
		}
	}
	
	Container Woning := for_each_ne(Classifications/ZichtJaar/Name
			,  Classifications/ZichtJaar/HasMutations
			? 'SelectT('+string(Classifications/ZichtJaar/Jaar)+','+string(MakeDefined(Classifications/ZichtJaar/Jaar[ID(Classifications/ZichtJaar)-1b], 0w))+', Classifications/BebouwingsComponentBase/V/NieuwbouwWoning)'
			: 'CalculationSchemes/LegeBebouwingsComponent(Classifications/WoningtypeNieuwbouw)'
			);

	Container Utiliteit := for_each_ne(Classifications/ZichtJaar/Name
			,  Classifications/ZichtJaar/HasMutations
			? 'SelectT('+string(Classifications/ZichtJaar/Jaar)+','+string(MakeDefined(Classifications/ZichtJaar/Jaar[ID(Classifications/ZichtJaar)-1b], 0w))+', Classifications/BebouwingsComponentBase/V/NieuwbouwUtil)'
			: 'CalculationSchemes/LegeBebouwingsComponent(Classifications/UtiltypeNieuwbouw)'
			);
			
	Container GlasTuinBouw:= for_each_ne(Classifications/ZichtJaar/Name
			,  Classifications/ZichtJaar/HasMutations
			? 'SelectT('+string(Classifications/ZichtJaar/Jaar)+','+string(MakeDefined(Classifications/ZichtJaar/Jaar[ID(Classifications/ZichtJaar)-1b], 0w))+', Classifications/BebouwingsComponentBase/V/NieuwbouwGlTb)'
			: 'CalculationSchemes/LegeBebouwingsComponent(Classifications/GLTB)'
			)
	{
//		container StartJaar := CalculationSchemes/LegeBebouwingsComponent(classifications/GLTB);
	}
}